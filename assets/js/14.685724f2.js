(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{432:function(t,e,s){"use strict";s.r(e);var a=s(15),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"c-11的decltype关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c-11的decltype关键字"}},[t._v("#")]),t._v(" C++11的decltype关键字")]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("decltype关键字和auto有异曲同工之处")]),t._v(" "),s("p",[t._v("有时我们希望"),s("strong",[t._v("从表达式的类型推断出要定义的变量类型")]),t._v("，但是不想用该表达式的值初始化变量（如果要初始化就用auto了）。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。")]),t._v(" "),s("h2",{attrs:{id:"使用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用方法"}},[t._v("#")]),t._v(" 使用方法")]),t._v(" "),s("div",{staticClass:"language-C++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("int getSize();\n\nint main(void)\n{\n    int tempA = 2;\n    \n    /*1.dclTempA为int*/\n    decltype(tempA) dclTempA;\n    /*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/\n    decltype(getSize()) dclTempB;\n\n    return 0;\n}\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br")])]),s("p",[t._v("还有很多用法，此处暂不深究。")]),t._v(" "),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),s("p",[s("code",[t._v("decltype")]),t._v("和"),s("code",[t._v("auto")]),t._v("都可以用来推断类型，但是二者有几处明显的差异：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("auto忽略顶层const，"),s("strong",[t._v("decltype保留顶层const")]),t._v("；")])]),t._v(" "),s("li",[s("p",[t._v("对引用操作，auto推断出原有类型，"),s("strong",[t._v("decltype推断出引用")]),t._v("；")])]),t._v(" "),s("li",[s("p",[t._v("对解引用操作，auto推断出原有类型，"),s("strong",[t._v("decltype推断出引用")]),t._v("；")])]),t._v(" "),s("li",[s("p",[t._v("auto推断时会实际执行，"),s("strong",[t._v("decltype不会执行，只做分析")]),t._v("。")])])]),t._v(" "),s("p",[t._v("总之在使用中过程中和const、引用和指针结合时需要特别小心。")]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[t._v("https://www.cnblogs.com/cauchy007/p/4966485.html")])])}),[],!1,null,null,null);e.default=n.exports}}]);